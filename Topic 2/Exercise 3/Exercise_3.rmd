---
title: 'Topic 2: Exercise 1'
author: "Daniel Alonso"
date: "November 28th, 2020"
output: 'pdf_document'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "./figures/"
)
knitr::knit_engines$set(julia = JuliaCall::eng_juliacall)
options(JULIA_HOME = "/home/dreth/julia/bin")
```


#### Importing libraries

```{r, echo=TRUE, warning=FALSE, message=FALSE}
library(dplyr)
library(Rcpp)
library(JuliaCall)
```

#### Importing data as described by exercise

```{r, echo=TRUE, warning=FALSE, message=FALSE}
d <- read.csv("../../datasets/Colleges.csv")
```

#### Replacing binary variable Private with 1 and 0

```{r, echo=TRUE, warning=FALSE, message=FALSE}
d$Private <- ifelse(d$Private == "Yes", 1, 0)
```

#### Selecting columns

```{r, echo=TRUE, warning=FALSE, message=FALSE}
data <- d %>% dplyr::select('Private','Apps','Accept','Enroll','F.Undergrad')
```

#### Calculating covariances

```{r, echo=TRUE, warning=FALSE, message=FALSE}
cov_matrix <- cov(data)
cov_matrix
```

\newpage

#### Calculating correlations

```{r, echo=TRUE, warning=FALSE, message=FALSE}
corr_matrix <- cov2cor(cov_matrix)
corr_matrix
```

#### Experimenting a little bit with the private variable

Let's try changing the Yes to 0 and the No to 1 and checking the covariances and correlations

```{r, echo=TRUE, warning=FALSE, message=FALSE}
d <- read.csv("../../datasets/Colleges.csv")
d$Private <- ifelse(d$Private == "Yes", 0, 1)
data <- d %>% dplyr::select('Private','Apps','Accept','Enroll','F.Undergrad')
```

```{r, echo=TRUE, warning=FALSE, message=FALSE}
cov_matrix <- cov(data)
cov_matrix
corr_matrix <- cov2cor(cov_matrix)
corr_matrix
```

We get the same numbers with reversed signs.

\newpage

### We define the following function (in julia) to help our understanding:
    
Takes the arguments:

    - nrows: number of data to simulate (amount of rows)
    - simulations: number of different times to simulate and average the results
    - fixed_value_col: boolean parameter with true -> assigns a set of values between mins[1] and maxs[1] (other 2 parameters)
    - reverse: boolean parameter that determines whether the 0s in the binary variable are assigned to the higher values or not
    - sim_binaries: this would simulate a rolling proportion of binaries where iteration 1 has all zeros in the binary variable and iteration *nrows* has all 1s in the binary variable
    - mins: array containing as first element the minimum value to use for corresponding values in the quantitative columns with 1s and 0s assuming the fixed_value_col parameter is set to false, if it's set to true then it'll be the minimum of the quantitative variable we are calculating the covariance or correlation vs the quantitative variable. the second element of the array represents the same minimum but for the 2nd array which will substitute the values of elements that are 1 or 0 depending on the user choice. (for example: if reverse=false, fixed_value_col=false, maxs=[10,10000] and mins=[1,100],  the values in the quantitative variable corresponding to 1s in the binary variable will, as the loop goes on, go from having minimum value 1 to minimum value 100 and with will go from having maximum value 10 to maximum value 10000, therefore assigning high values (between 100-10000) to elements in the quant.variable corresponding to 1 in the binary variable and keep lower values (between 1-10) for the ones corresponding to 0s in the binary variable)
    - maxs: same as minimum but they're the maximums.

Example of how the dataset changes for a run of the function with parameters: nrows=5, simulations=1 and the rest of the parameters as default:

![Example of a simulated dataset with the function simulation_general in the Julia REPL](julia_output.png)

In Figure 1 we can see 5 iterations (as there's 5 simulated rows) using the function, where the leftmost value of each row is a binary variable (1 or 0), starting with (1,0,0,0,0) and ending with (1,1,1,1,1), and for our quantitative variable (with which we will calculate cov/corr) we can see the values go from a high value (copied from the 3rd column) and the rest of values being small (6565,7,1,5,8) and ending with large values (copied from column 3) being (6565, 8180, 6214, 4544, 3441). 

### Function definition

```{julia}
using Random
using Statistics
using Plots
gr()

function simulation_general(nrows, simulations; fixed_value_col=false, reverse=false, sim_binaries=true, mins=[1,100], maxs=[10,10000]) 
    # cov and corr matrixes
    covs = zeros(Float64, nrows, simulations)
    corr = zeros(Float64, nrows, simulations)

    # loop
    for s in 1:simulations
        pvtapps = zeros(Float64, nrows, 3)
        if sim_binaries == false
            pvtapps[:,1] = rand(0:1, nrows)
        end

        # random numbers column (quant variable)
        if fixed_value_col == true
            pvtapps[:,2] = rand(mins[1]:maxs[1],nrows)
        else
            if reverse == false
                pvtapps[:,2] = rand(mins[1]:maxs[1],nrows)
                pvtapps[:,3] = rand(mins[2]:maxs[2],nrows)
            else 
                pvtapps[:,2] = rand(mins[2]:maxs[2],nrows)
                pvtapps[:,3] = rand(mins[1]:maxs[1],nrows)
            end
        end

        # loop for changing values
        for i in 1:nrows

            if sim_binaries == true
                pvtapps[1:i,1] = ones(i)
            end

            pvtapps[1:i,2] = pvtapps[1:i,3]

            # calculate corr and cov
            covs[i,s] = cov(pvtapps[:,1],pvtapps[:,2])
            corr[i,s] = cor(pvtapps[:,1],pvtapps[:,2])
        end
    end

    # results
    covsrows = zeros(Float64, nrows)
    corrrows = zeros(Float64, nrows)
    for i in 1:nrows
        covsrows[i] = mean(covs[i,:])
        corrrows[i] = mean(corr[i,:])
    end

    # return matrixes
    return covsrows, corrrows
end

covsrows, corrrows = simulation_general(500,100, reverse=false, sim_binaries=true);
covsrows_rev, corrrows_rev = simulation_general(500,100, reverse=true, sim_binaries=true);
```

\newpage

#### Covariance plot with 500 data points and 100 simulations averaged

```{r, echo=TRUE, warning=FALSE, message=FALSE}
covsrows <- JuliaCall::julia_eval("covsrows")
plot(covsrows)
```

Each point here corresponds to one iteration of the function (leftmost being an iteration where the binary variable had its first value as 1 and the rest as 0 and rightmost being all 1s). For each 1 in the binary variable we have a value between 100 and 10000 in the quantitative variable used to calculate the covariance. For each 0 we have a value between 1 and 10, therefore, all values in the quantitative variable corresponding to a 0 in the binary are at least an order (x10) of magnitude larger than those corresponding to a 1.

Clearly, as long as values in the quantitative variable (corresponding to 1 in the binary variable) remain significantly larger than those corresponding to 0 the 0 in the binary variable, our covariance will grow as the proportion of 1s grow, however, once we reach half and half (half 0s and half 1s in the binary variable), our function reaches its global maximum and becomes a decreasing function. 

The opposite thing would happen if we reverse the values of the 

```{r, echo=TRUE, warning=FALSE, message=FALSE}
covsrows_rev <- JuliaCall::julia_eval("covsrows_rev")
plot(covsrows_rev)
```

#### Correlation plot with 500 data points and 100 simulations averaged

```{r, echo=TRUE, warning=FALSE, message=FALSE}
corrrows <- JuliaCall::julia_eval("corrrows")
plot(corrrows)
```

# OBSERVATIONS

Now let's play around changing the size of the values that correspond in the quantitative variable to 1s or 0s in the binary column.



## What information does the sample covariance provide?

We know that because the Private variable (binary variable) has only 2 possible values, its covariance with other variables is always going to be relatively small and will not provide much information.

\newpage

## What information does the sample correlation provide?



